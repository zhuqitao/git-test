[{"title":"实现一个redux","url":"/zqt-blog/2018/10/15/实现一个迷你版的redux/","content":"#实现一个redux\n## 先不考虑中间件，实现一个简洁的redux\n### 实现createStore\ncreateStore是redux最主要的一个API了，通过createStore可以创建一个store用来存放应用中所有的state，一个应用只能有一个store。\n\n```\n// 先创建一个mini-redux.js文件:\nexport function createStore(reducer) {\n    // 初始化store\n    let currentStore = {};\n    // 初始化事件列表\n    let currentListeners = [];\n    \n    // 获取state\n    function getState() {\n        return currentStore;\n    }\n    // 订阅事件\n    function subscribe(listener) {\n        currentListeners.push(listener);\n    }\n    // 定义dispatch方法\n    function dispatch(action) {\n        currentStore = reducer(currentStore, action);\n        currentListeners.forEach(v => v());\n        // return dispatch;\n    }\n    // 默认执行reducer type类型不要命中reducer中自定义的case\n    dispatch({type: '@ZQT-REDUX'});\n    return {getState, subscribe, dispatch}\n}\n```\n上面创建了一个redux.js文件，并暴露了一个createStore方法，接受reducer作为参数\n\n```\n// 创建mini-react-redux.js\nimport React from 'react';\nimport PropTypes from 'prop-types';\n\nexport const connect = (mapStateToProps = state => state, mapDispatchToProps = {}) => (WrapComponent) => {\n    return class connentComponent extends React.Component{\n        static contextTypes = {\n            store: PropTypes.object\n        }\n        constructor(props, context) {\n            super(props, context);\n            this.state = {\n                props: {}\n            }\n        }\n        componentDidMount() {\n            const {store} = this.context;\n            // 为什么非要订阅  因为没一个connect实际上就是一个订阅  每当dispatch执行的时候  就要重新执行以下update方法\n            store.subscribe(() => this.update());\n            this.update();\n        }\n        update = () => {\n            const {store} = this.context;\n            const stateProps = mapStateToProps(store.getState());\n\n            // 每一个action需要用dispatch包裹一下\n            const stateDispatch = bindActionCreators(mapDispatchToProps, store.dispatch);\n            this.setState({\n                props: {\n                    ...this.props,\n                    ...stateProps,\n                    ...stateDispatch\n                }\n            })\n        }\n        render() {\n            return <WrapComponent {...this.state.props}/>\n        }\n    }\n}\n\nexport class Provider extends React.Component{\n    static childContextTypes = {\n        store: PropTypes.object\n    }\n    getChildContext() {\n        return {\n            store: this.store\n        }\n    }\n    constructor(props, context) {\n        super(props, context);\n        this.store = props.store;\n    }\n    render() {\n        return this.props.children\n    }\n}\n\nfunction bindActionCreators(creators, dispatch) {\n    const bound = {};\n    Object.keys(creators).forEach(v => {\n        bound[v] = bindActionCreator(creators[v], dispatch);\n    })\n    return bound;\n}\nfunction bindActionCreator(creator, dispatch) {\n    return (...args) => dispatch(creator(...args))\n}\n\n```\n上面创建了mini-react-redux.js文件，主要暴露了connect方法和Provider组件。\n\n先看Provider组件。Provider利用的react的context属性，把store注入到Provider组件，并返回this.props.children(也就是Provider组件里面嵌入的组件，一般是页面的跟组件App组件)，这样所有的组件都可以共享store。\n\n然后再看connect方法。connect方法是一个双重嵌套的方法(专业名词叫函数柯里化)里面的方法接受一个组件并且返回一个组件，正式高阶组件的用法，外面的函数接受mapStateToProps和mapDispatchToProps两个参数，mapStateToProps是用来把store里面的数据映射到组件的props属性中，mapDispatchToProps是把用户自己定义的action映射到组件的props属性中。\n\n在componentDidMount方法里面执行了store.subscribe(() => this.update())这句代码，是因为每次使用dispatch触发一个action的时候都要执行一下update方法，即重新获取store数据并映射到组件中去，这样才能保证store数据发生变化，组件props能同时跟着变化。\n\nbindActionCreators方法是用来把每一个action用dispatch方法包裹一下，因为action可能只是返回一个具有type属性的对象，只有用dispatch执行action才有意义。\n\n>到此为止，一个没有中间件的不支持异步dispatch的简洁版的redux已经实现了，创建一个demo，就可以看到效果了\n```\n// 创建index.js 作为项目入口文件，大家可以自己添加action和reducer，就可以查看效果\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport { createStore, applyMiddleware } from './mini-redux';\nimport { counter } from './index.redux'\nimport { Provider } from './mini-react-redux';\nimport App from './App'\n\nconst store = createStore(counter);\nReactDOM.render(\n  (\n    <Provider store={store}>\n      <App />\n    </Provider>\n  ),\n  document.getElementById('root'))\n```\n\n## 支持中间件和异步action的redux实现\n上面实现了简洁版的redux，再此基础上添加支持中间件的代码\n\n```\n// 修改mini-redux.js为\nexport function createStore(reducer, enhancer) {\n    if(enhancer) {\n        return enhancer(createStore)(reducer)\n    }\n    let currentStore = {};\n    let currentListeners = [];\n\n    function getState() {\n        return currentStore;\n    }\n\n    function subscribe(listener) {\n        currentListeners.push(listener);\n    }\n\n    function dispatch(action) {\n        currentStore = reducer(currentStore, action);\n        currentListeners.forEach(v => v());\n        // return dispatch;\n    }\n\n    dispatch({type: '@ZQT-REDUX'});\n    return {getState, subscribe, dispatch}\n}\n\nexport function applyMiddleware(...middlewares) {\n    return createStore=>(...args)=> {\n        // 这里args 就是上面createStore 传过来的reducers\n        const store = createStore(...args)\n        let dispatch = store.dispatch\n        // 暴漏 getState 和 dispatch 给 第三方中间价使用\n        const midApi = {\n            getState: store.getState,\n            dispatch: (...args) => dispatch(...args)\n        }\n        // 创造第三方中间件使用 middlewareAPI 后返回的函数组成的数组\n        const middlewareChain = middlewares.map(middleware => middleware(midApi))\n        // 结合这一组函数 和 dispatch 组成的新的 dispatch，然后这个暴漏给用户使用，而原有的 store.dispatch 是不变的，但是不暴漏\n        dispatch = compose(...middlewareChain)(store.dispatch);\n        return{\n            ...store,\n            dispatch\n        }\n    }\n}\n\nexport function compose(...funcs) {\n    if(funcs.length === 0){\n        return arg => arg\n    }\n    if(funcs.length === 1) {\n        return funcs[0]\n    }\n    return funcs.reduce((ret, item) => (...args) => item(ret(...args)));\n}\n\n```\ncreateStore方法修改了一下，多接受了一个enhancer方法，enhancer就是在index.js创建store的时候传过来的applyMiddleware方法。判断是否传了enhancer参数，如果有就return enhancer(createStore)(reducer)\n\napplyMiddleware方法接受多个中间件作为参数，这个方法的最终目的就是创建一个新的dispatch属性，新的dispatch属性是经过中间件修饰过的，并且暴露这个新的dispatch属性，原来的dispatch属性不变。\n\ncompose方法是一个可以吧compose(fn1,fn2,fn3)(arg)转为fn3(fn2(fn1(arg)))的方法，也就是fn1的执行结果作为fn2的参数，fn2的执行结果作为fn1的参数，依次类推。正好可以利用reduce的特性实现这个效果。\n\n```\nconst thunk = ({getState, dispatch}) => next => action => {\n    // 如果是函数  就执行action\n    if(typeof action === 'function') {\n        return action(dispatch, getState)\n    }\n    return next(action)\n}\nexport default thunk\n```\n异步action在定义的时候返回的就是一个接受一个dispatch的方法，所以如果action是一个函数，就吧dispatch和getState方法传给该action，并且执行该action。如果不是一个函数，就直接返回action。\n\n> 到此为止一个支持中间件的redux就实现了，该demo只是为了学习redux的思想，不能作为真正的redux来使用，有很多类型检查代码都省略了\n\n从实现迷你版的redux可以体会到redux精巧的设计和函数式编程的魅力，有队函数式编程感兴趣的可以看一下这篇文章https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch1.html\n\ngithub源码地址：https://github.com/zhuqitao/zqt-redux","tags":["javascript"]},{"title":"ES6常用知识总结","url":"/zqt-blog/2018/08/04/es6常用总结/","content":"\n#ES6常用知识总结\n\n> 之前总结了es5中js的一些知识点。这段时间看了石川blue老师讲解的es6课程，结合阮一峰老师的es6教程，随手做了一些笔记和总结分享给大家。内容还是es6主要的知识点，基本没有什么创新点，主要是石川blue对里面一些难懂的知识点分析的挺好的，对我个人理解es6很有帮助，也希望对大家能有所帮助。\n\n石川blue老师es6讲解视频百度云地址：[https://pan.baidu.com/s/1qZpUeni ][1]  密码：2m9t\n\n## es6 是什么\n\n首先弄明白ECMA和js的关系。ECMA是标准，Javascript是ECMA的实现。因为js也是一种语言，但凡语言都有一套标准，而ECMA就是javascript的标准。\n在2015年正式发布了ECMAscript6.0，简称ES6，又称为ECMAscript2015。\n\n## 1. let const\n在es6之前，定义变量都是使用var，但是var存在一些问题，比如可以重复声明，仅支持函数作用域问题。所以es6设计了let和const来弥补不足的地方，下面看一下let和const具备哪些特性\n\n**let**\n - 不能重复声明\n - 块级作用域\n - 可修改let变量的值\n**const**\n - 不可重复声明\n - 块级作用域\n - 不可修改const变量的值\n\n## 2. 箭头函数\n\n**箭头函数在写法上对es5做了一些修整，代码看起来更显得简洁**\n\n - 如果只有一个参数，圆括号\"()\"可以省略\n - 函数体如果只有一句return语句，花括号也可以省略\n\n```\n// 定义一个箭头函数\nlet a = (arg)=>{ //  这里=>符号就相当于function关键字\n    return arg+=1\n}\n// 也可以简写为\nlet a = arg => arg+=1\n```\n**箭头函数也对this的指向做了修整**\nes6之前的函数的this指向调用函数时所在的对象，而箭头函数的this指向函数定义时所在的对象\n\n```\n// 普通函数\n var obj = {\n   say: function () {\n     setTimeout(function() {\n       console.log(this)\n     });\n   }\n }\n// 箭头函数\nvar obj = {\n    say: function () {\n        setTimeout(() => {\n            console.log(this)\n\t\t});\n\t}\n}\nobj.say(); // obj\n```\n\n##3. 解构赋值\n允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构。比如：\n\n```\nvar [a,b] = [1,2]\n// a=1  b=2\n```\n\n解构赋值必须符合下面三条规则：\n\n - 左右结构必须一样\n - 右边必须是一个合法的数据\n - 声明和赋值必须一句话完成，不能把声明与赋值分开\n\n```\nlet [a, b] = [1, 2]                // 左右都是数组，可以解构赋值\nlet {a, b} = {a:1, b:2}            // 左右都是对象，可以解构赋值\nlet [obj, arr] = [{a:1}, [1, 2]]   // 左右都是对象，可以解构赋值\n\nlet [a, b] = {a:1, b:2}            // err 左右结构不一样，不可以解构赋值\nlet {a,b} = {1, 2}                 // err 右边不是一个合法的数据，不能解构赋值\n\nlet [a, b];\n[a, b] = [1, 2]                    // err 声明与赋值分开，不能解构赋值\n```\n\n## 4. 字符串\n\n**1.字符转模板**\n\n字符转模板使用反引号(``)来定义字符串，字符串模板支持断行，也可以在字符串嵌入变量，非常方便，可谓是前端的福利。\n\n```\nlet name = 'Jone'\n`hello ${name},\nhow are you\n`\n```\n**2. startsWith(), endsWith(), includes()**\n\n - startsWith()  表示参数字符串是否在原字符串的头部，返回布尔值\n - endsWith()    表示参数字符串是否在原字符串的尾部，返回布尔值\n - includes()    表示是否在原字符串找到了参数字符串，返回布尔值\n这三个方法都支持第二个参数，表示开始搜索的位置。\n\n```\nlet s = 'Hello world!';\n\ns.startsWith('world', 6) // true\ns.endsWith('Hello', 5) // true\ns.includes('Hello', 6) // false\n```\n\n\n\n## 5. 数组\n石川blue老师讲的是es6对数组扩展了4个方法：map、reduce、filter、forEach。我认为这四个方法好像在es5就有了（个人感觉，有可能不对），不管这四个方法是es5还是es6添加的方法了，大家对这几个函数应该都挺熟悉，就不多做介绍了，下面说一下es6对数组扩展的其他的新特性。\n**扩展运算符**\n扩展运算符（spread）是三个点（...），它可以将一个数组拆分为参数序列，也可以收集剩下的所有的参数或者数组元素。\n\n\n```\n// 将一个数组拆分为参数序列\nlet arr = [1,2]\nfunction add (a,b) {\n    return a+b\n}\nadd(...arr)\n\n// 收集剩下的所有的参数\nfunction f(a, ...arr) {\n    console.log(...arr) // 2 3\n}\nf(1,2,3)\n\n// 用于数组复制\nlet arr1 = [1,2]\nlet arr2 = [...arr1] // 或者let [...arr2] = arr1\n```\n##6. 面向对象 class\nES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。\n先看如何定义一个class类：\n\n```\nclass User {\n    constructor(name) {          // 构造器，相当于es5中的构造函数\n        this.name = name         // 实例属性\n    }\n    showName(){                  // 定义类的方法，不能使用function关键字，不能使用逗号分隔\n        console.log(this.name)   \n    }\n}\nvar foo = new User('foo')\n```\n\n###(1)constructor\n\n - es6中class类专用的构造器，相当于之前定义的构造函数，每个类都必须有constructor，如果没有则自动添加一个空的constructor构造器。\n - 创建实例的时候自动执行constructor函数\n - constructor中的this指向实例，并且默认返回this（实例）\n\n### (2)class类的prototype\n 其实class的基本类型就是函数（typeof User = \"function\"），既然是函数，那么就会有prototype属性。\n\n类的所有方法都是定义在prototype上\n\n```\nclass User {\n  constructor() {\n    // ...\n  }\n\n  toString() {\n    // ...\n  }\n\n  toValue() {\n    // ...\n  }\n}\nUser.toValue()             // err User.toValue is not a function\nUser.prototype.toValue()   // 可以调用toValue方法\n\n// 等同于\n\nUser.prototype = {\n  constructor() {},\n  toString() {},\n  toValue() {},\n};\n```\n### (3)类的实例\n\n - 类的实例只能通过new来创建\n - 除了静态方法，定义在类上的所有的方法都会被实例继承\n - 除非定义在类的this对象上才是实例属性，否则都是定义在类的原型（prototype）上\n\n```\n//定义类\nclass Point {\n\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  toString() {\n    return '(' + this.x + ', ' + this.y + ')';\n  }\n\n}\n\nvar point = new Point(2, 3);\n\npoint.toString() // (2, 3)\n\npoint.hasOwnProperty('x') // true\npoint.hasOwnProperty('y') // true\npoint.hasOwnProperty('toString') // false\npoint.__proto__.hasOwnProperty('toString') // true\n```\n\n###(4)静态方法\n如果在类中定义一个方法的前面加上static关键字，就表示定义一个静态方法，静态方法不会被实例继承，但会被子类继承，所以不能通过实例使用静态方法，而是通过类直接调用。\n\n```\nclass User {\n\tconstructor(name){\n\t\tthis.name = name\n\t}\n\tstatic show(){\n\t\tconsole.log('123')\n\t}\n}\nclass VipUser extends User{}\nVipUser.show()                    // 123\nUser.show()                       // 123\nvar foo = new User('foo')\nfoo.show()                        // foo.show is not a function\n```\n\n###(5)静态属性\n\n - class的静态属性指的是 Class 本身的属性，目前只能通过Class.propName定义静态属性\n - 静态属性可以被子类继承，不会被实例继承\n\n```\nclass User{}\nUser.name = 'foo' // 为class定义一个静态属性\n\nclass VipUser extends User{}\nconsole.log(VipUser.name)         // foo\n\nvar foo = new User()\nconsole.log(foo.name)             // undefined\n```\n\n###(6)私有属性和私有方法\nes6是不支持私有属性和私有方法，但是日常需求可能会用到私有属性和私有方法，所以目前有一些提案，不过只是提案，尚未支持。\n\n\n\n\n##7. 类的继承\nclass通过extends关键字实现继承：\n\n```\nclass User {\n    constructor(name){\n        this.name = name\n    }\n    show(){...}\n}\nclass VipUser extends User{\n    constructor(vipName){      // 子类的构造器\n        super(vipName)         // 调用父类的constructor。相当于User.prototype.constructor.call(this,vipName)\n    }\n    showVip(){...}\n}\n\nvar v = new VipUser('foo')     // 创建实例\nv instanceof VipUser           // v是子类VipUser的实例\nv instanceof User              // v还是父类User的实例\n```\n###(1)super\nsuper可以当做函数使用，也可以当做对象使用。\n\n - **当做函数使用**\nsuper作为函数调用时，代表父类的构造函数，就是在子类的构造器中执行父类的constructor函数以获取父类的this对象，因为子类没有自己的this对象，所以ES6规定子类必须在constructor中执行一次super函数。super()函数只能在子类的constructor中执行，不能在其他地方执行。\n\n虽然super代表父类的构造器，但是super()在执行时内部的this指向子类，所以super()就相当于User.prototype.constructor.call(this)。\n\n - **当做对象使用**\n\nsuper可以作为对象调用父类的属性和方法，在子类的普通方法中，指向父类的原型对象（即User.prototype）；在子类的静态方法中，指向父类。\n\n```\nclass User {\n  constructor(){\n    this.x = 'hello'\n  }\n  show() {\n    return 2;\n  }\n}\n\nclass VipUser extends User {\n  constructor() {\n    super();\n    console.log(super.show()); // 2  此时super指向User.prototype,相当于User.prototype.show()\n    console.log(super.x)       // undefined  无法访问实例属性\n  }\n}\n\nlet vip = new VipUser();\n```\n\n由于super对象在普通函数中使用super指向User.prototype，所以super只能访问父类的原型上的方法，没法访问父类的实例属性和实例方法。\n\n\nES6规定如果在子类中使用super对象调用父类的方法时，方法内部的this指向子类\n\n```\nclass User {\n    constructor() {\n        this.x = 1\n    }\n    show() {\n        return this.x;\n    }\n}\n\nclass VipUser extends User {\n    constructor() {\n        super();\n        this.x = 2\n        console.log(super.show())   // 2   此时show()方法内部的this指向子类，所以输出2，而不是1\n    }\n}\n\nlet vip = new VipUser();\n```\n\n上述代码中虽然super.show()调用的是User.prototype.show()，但是由于通过super对象调用父类方法时，方法内部的this指向子类，所以super.show()相当于 super.show().call(this)，也就是User.prototype.show().call(this)\n\n\n在子类的静态方法中super对象指向父类，而不是父类的原型（User.prototype）。\n\n```\nclass User {\n    constructor() {\n        this.x = 1\n    }\n    static fn() {\n        console.log('父类静态方法')\n    }\n}\n\nclass VipUser extends User {\n    constructor() {\n        super();\n        this.x = 2\n    }\n    static childFn() {\n        super.fn()       // 相当于User.fn()\n    }\n}\n\nVipUser.childFn()\n```\n\n###(2)类的prototype和__proto__属性\n\n在es5中每一个对象都有__proto__属性，指向对应的构造函数的prototype属性。Class 作为构造函数的语法糖，同时有prototype属性和__proto__属性，因此同时存在两条继承链。\n\n - **子类的__proto__属性，表示构造函数的继承，总是指向父类。**\n - **子类prototype属性的__proto__属性，表示方法的继承，总是指向父类的prototype属性。**\n\n```\nclass User {\n}\n\nclass VipUser extends User {\n}\n\nVipUser.__proto__ === User // true\nVipUser.prototype.__proto__ === User.prototype // true\n```\n\n###(3)实例的__proto__属性\n子类实例的__proto__属性指向子类的原型（子类的prototype），子类实例的__proto__属性的__proto__属性指向父类的原型（父类的prototype）\n\n```\nclass User {\n}\n\nclass VipUser extends User {\n}\n\nvar vip = new VipUser()\n \nconsole.log(vip.__proto__ === VipUser.prototype)           // true\nconsole.log(vip.__proto__.__proto__ === User.prototype)    // true\n```\n\n\n##8. 对象\n\n###(1) 对象的扩展运算符 ...\n对象的扩展运算符（...）可以把对象可枚举的属性拆分为键值对序列\n\n - 用于对象拷贝\n\n```\nlet obj1 = {a:1,b:2}\nlet obj2 = {...obj1}\nconsole.log(obj2)   // {a:1,b:2}\n```\n\n - 用于合并对象\n\n```\nlet obj1 = {a:1,b:2}\nlet obj2 = {c:3,d:4}\nlet obj3 = {a:100, ...obj1, ...obj2, e:5, f:6}  // {a: 1, b: 2, c: 3, d: 4, e: 5, f: 6}\nlet obj4 = { ...obj1, ...obj2, e:5, f:6, a:100} // {a: 100, b: 2, c: 3, d: 4, e: 5, f: 6}\n```\n\n如果后面的属性和前面的属性key相同，则会覆盖前面的值\n\n###(2) Object.assign\nObject.assign方法用于对象的合并，将源对象（source）的所有可枚举属性，拷贝(浅拷贝)到目标对象。\n\n如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。\n\n```\nconst target = { a: 1 };\n\nconst source1 = {a: 100, b: 2 };\nconst source2 = { c: 3 };\n\nObject.assign(target, source1, source2);\ntarget // {a:100, b:2, c:3}\n```\n\nObject.assign拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性。\n\n###(3) Object.keys()，Object.values()，Object.entries()\n\nES2017 引入了跟Object.keys、Object.values和Object.entries，作为遍历一个对象的补充手段，供for...of循环使用。\n\n - Object.keys() 返回一个数组，成员是参数对象所有可枚举的属性的键名\n\n```\nvar obj = { foo: 'bar', baz: 42 };\nObject.keys(obj) // [\"foo\", \"baz\"]\n```\n\n - Object.values() 返回一个数组，成员是参数对象所有可枚举属性的键值。\n\n```\nconst obj = { 100: 'a', 2: 'b', 7: 'c' };\nObject.values(obj)  // [\"b\", \"c\", \"a\"]\n```\n\n - Object.entries() 返回一个数组，成员是参数对象所有可枚举属性的键值对数组。\n\n```\nconst obj = { foo: 'bar', baz: 42 };\nObject.entries(obj)  // [ [\"foo\", \"bar\"], [\"baz\", 42] ]\n```\n\n## 9. Generator函数\nGenerator可以理解为生成器，和普通函数没多大区别，普通函数是只要开始执行，就一直执行到底，而Generator函数是中间可以停，搭配使用next函数继续执行，用石川blue老师的话说就是踹一脚走一步。\n\n###(1)定义一个Generator函数\n\n```\nfunction * fn(){\n    alert('a')\n    yield\n    alert('b')\n}\n\nvar f = fn()\nf.next()  // a\nf.next()  // b\n```\n直接调用Generator函数，是什么都不执行的，调用第一个next()才开始执行，一直执行到第一个yield停止，第二次调用next()，从第一个yield执行到第二个yield停止，依次类推\n###(2)yield和nwxt\nyield代表暂时暂停执行，next代表继续执行。\n\nyield和next可以传参数，也可以有返回值\n\n```\n1  function * fn(arg){\n2      console.log(arg)\n3      let x = yield 100\n4      console.log(x)\n5      return 200\n6  }\n7 \n8  var f = fn('hello')\n9  let step1 = f.next(1)\n10 console.log(step1)\n11 let step2 = f.next(2)\n12 \n\n// 输出结果为\n// hello\n// {value: 100, done: false}\n// 2\n// {value: 200, done: true}\n```\n先看第八行 var f = fn('hello')，可以给Generator第一次执行传参数'hello'，等第一次调用next的时候就开始Generator第一次执行，这时arg的值就是'hello'\n\n然后第九行let step1 = f.next(1)，这里需要注意，第一次调用next(1)时传的参数是作废的，所以1不会被传入到Generator函数中去，因为Generator函数第一次执行传的参数是通过上面传arg的方式传的参数。所以调用next()开始Generator第一次执行（console.log(arg)）,此时arg的值是‘hello’，所以首先打印‘hello’\n\n然后第十行打印step1的返回值。其实next是有返回值的，返回值是一个对象，其中value属性的值就是第一个yield返回的值100，done代表Generator时候执行完毕。\n\n然后第十一行let step2 = f.next(2)，这里的next(2)的参数可以传到Generator函数中去，但是为什么把2传给了x，估计很多人都想不明白，下面借鉴石川blue老师画的一张图来解释一下：\n\n\n![clipboard.png](/img/bV4QEW)\n\n\n看到黄色方框圈的let step1 = f.next(1)，对应执行黄色曲线圈的那部分代码，红色方框圈的let step12= f.next(2)对应执行红色曲线圈的部分代码，不要管为什么，你只需要这么理解就ok了。所以第二次next(2)传的参数2就传给了x\n\n然后再看第十二行console.log(step2)，所以第二个next的返回值就是对象{value: 200, done: true}，value表示最后Generator函数的返回值return 200，done表示Generator函数执行完毕。\n\n###(3) 适用场景\n这种Generator函数适用多个异步请求之间有逻辑分析的情况，比如有一个需求，先请求用户数据，根据用户数据的类型判断用户是普通用户还是VIP用户，然后再根据判断结果请求普通商品数据或者VIP商品数据。\n\n```\n// 借助runner脚本，runner脚本规定Generator函数执行完一个next之后自动执行下一个next\nrunner(function() * (){\n    let userData = yield $.ajax(...) // 请求用户数据\n    if(userData.type === 'vip') {\n        let goods = yield $.ajax(...) // 请求vip商品数据\n    } else {\n        let goods = yield $.ajax(...) // 请求普通商品数据\n    }\n})\n```\n使用Generator函数使得代码看起来更像同步代码，其实使用Promise同样可以实现这种效果，只不过得需要在then()函数中嵌套请求。\n\n\n\n\n\n## 9. async await\nasync其实就是对Generator的封装，只不过async可以自动执行next()。\n\n```\nasync function read () {\n    let data1= await new Promise(resolve => {\n        resolve('100')\n    })\n    let data2 = await 200\n    \n    return 300\n}\n\n```\n\n###(1)async 返回值\nasync默认返回一个Promise，如果return不是一个Promise对象，就会被转为立即resolve的Promise，可以在then函数中获取返回值。\n\nasync必须等到里面所有的await执行完，async才开始return，返回的Promise状态才改变。除非遇到return和错误。\n\n```\nasync function fn () {\n    await 100\n    await 200\n    return 300\n}\nfn().then(res => {\n    console.log9(res) // 300\n})\n```\n\n###(3)await \n\nawait也是默认返回Promise对象，如果await后面不是一个Promise对象，就会转为立即resolve的Promise\n\n如果一个await后面的Promise如果为reject，那么整个async都会中断执行，后面的awiat都不会执行，并且抛出错误，可以在async的catch中捕获错误\n\n```\nasync function f() {\n  await Promise.reject('error');\n  await Promise.resolve('hello world'); // 不会执行\n}\nf().then(res =>{\n\n}).catch(err=>{\n    console.log(err)  // error\n})\n```\n\n如果希望一个await失败，后面的继续执行，可以使用try...catch或者在await后面的Promise跟一个catch方法：\n\n```\n// try...catch\nasync function f() {\n  try {\n    await Promise.reject('出错了');\n  } catch(e) {\n  }\n  return await Promise.resolve('hello world');\n}\n\nf()\n.then(v => console.log(v))   // hello world\n\n// catch\nasync function f() {\n  await Promise.reject('出错了')\n    .catch(e => console.log(e));   // 出错了\n  return await Promise.resolve('hello world');\n}\n\nf()\n.then(v => console.log(v))  // hello world\n```\n\n\n  [1]: https://pan.baidu.com/s/1qZpUeni","tags":["javascript"]},{"title":"前端性能优化总结","url":"/zqt-blog/2018/02/28/前端性能优化篇/","content":"\n#前端性能优化总结\n\n## 资源优化\n\n### 缓存\n最好的资源优化就是不加载资源。缓存也是最见效的优化手段。说实话，虽然说客户端缓存发生在浏览器端，但缓存主要还是服务端来控制，与我们前端关系并不是很大。但还是有必要了解一下。\n\n缓存包括服务端缓存和客户端缓存，本文只谈客户端缓存。所谓客户端缓存主要是http缓存。http缓存主要分为强制缓存和协商缓存。\n\n#### 强制缓存\n\n - Expires（http1.0）\n在http1.0中使用Expires来做强制缓存。Exprires的值为服务端返回的数据到期时间。当再次请求时的请求时间小于返回的此时间，则直接使用缓存数据。但由于服务端时间和客户端时间可能有误差，这也将导致缓存命中的误差。\n\n - Cache-Control\nCache-Control有很多属性，不同的属性代表的意义也不同。\n\n 1. private：客户端可以缓存\n 2. public：客户端和代理服务器都可以缓存\n 3. max-age=t：缓存内容将在t秒后失效\n 4. no-cache：需要使用协商缓存来验证缓存数据\n 5. no-store：所有内容都不会缓存。\n\n#### 协商缓存\n浏览器第一次请求数据时，服务器会将缓存标识与数据一起响应给客户端，客户端将它们备份至缓存中。再次请求时，客户端会将缓存中的标识发送给服务器，服务器根据此标识判断。若未失效，返回304状态码，浏览器拿到此状态码就可以直接使用缓存数据了。\n\n - Last-Modified\n服务器在响应请求时，会告诉浏览器资源的最后修改时间\n - if-Modified-Since\n浏览器再次请求服务器的时候，请求头会包含此字段，后面跟着在缓存中获得的Last-Modified（最后修改时间）。服务端收到此请求头发现有if-Modified-Since，则与被请求资源的最后修改时间进行对比，如果大于被请求资源最后修改时间则返回304，浏览器从缓存获取资源。如果小于被请求资源最后修改时间，则返回200，并返回最新资源，浏览器从服务端获取最新的资源，并缓存。\n - Etag\n由服务器生成的每个资源的唯一标识字符串\n - If-None-Match\n再次请求服务器时，浏览器的请求报文头部会包含此字段，后面的值为在缓存中获取的标识。服务器接收到次报文后发现If-None-Match则与被请求资源的唯一标识进行对比。如果相同，说明资源没有被修改过，返回304，浏览器从缓存获取资源，如果不同说明资源被修改过，则返回200，并返回最新资源，浏览器从服务端获取最新资源，并缓存。\n\n> Last-Modified与ETag是可以一起使用的，服务器会优先验证ETag，一致的情况下，才会继续比对Last-Modified，最后才决定是否返回304。\n\n如果使用前端打包工具，可以在打包文件时候在给文件添加版本号或者hash值，同样可以区分资源是否过期。\n\n### 减少http请求\n\n - 使用CDN托管静态资源\n - 可以借助gulp、webpack等打包工具对js、css等文件合并与压缩\n - 图片懒加载、按需加载，当滚动到图片可视区域才去加载图片\n - 小图片并且基本不会改动的图片使用base64编码传输。base64不要滥用，即使小图片经过base64编码之后也会生成很长的字符串，如果滥用base64反而会适得其反\n - 雪碧图，这个也是针对基本不会更改的图片才使用雪碧图，因为如果一张图片修改，会导致整个雪碧图重新生成，如果乱用也会适得其反。\n\n### 减小http请求资源体积\n\n - 借助webpack、gulp等工具压缩资源\n - 服务端开启gzip压缩（压缩率非常可观，一般都在30%之上）\n - 如果有用打包工具，打包优化要做好，公共资源、提取第三方代码、不需要打包的库...\n\n\n\n\n##渲染优化\n\n\n> 读过前面js运行机制的应该知道，从浏览器输入url，到页面出现在屏幕上，都发生了哪些事（tcp握手、dns解析等不在认知范围）。\n\n - FPS 16ms 小于10ms完成最好  Google devtool 查看帧率\n如果浏览器FPS到达60，就会显得比较流畅，大多数显示器的刷新频率是60Hz，浏览器会自动按照这个频率刷新动画。\n按照FPS等于60来计算，平均一帧的时间为1000ms/60 = 16.7ms，所以每次渲染时间不能超过16ms，如果超过这个时间就会出现丢帧、卡顿现象。\n\n可以在chrome浏览器开发者工具中的Timeline中查看刷新率，可以查看所有帧率耗时情况以及某一帧的执行情况。Timeline的使用教程：[https://segmentfault.com/a/1190000003991459][1]\n\n为了保证正常的FPS，有些渲染性能优化还是有必要的。下面所介绍的都是有关渲染优化的策略。\n\n - 尽量使用css3来做动画\n总所周知，css的性能要比js快，所以能使用css，尽量不用js来实现\n\n - 避免使用setTimeout或setInterval，尽量使用requestAnimationFrame来做动画或者高频Dom操作。\n因为setTimeout和setInterval无法保证callback函数的执行时机，很可能在帧结束的时候执行，从而导致丢帧，但是requestAnimationFrame可以保证callback函数在每帧动画开始的时候执行\nrequestAnimationFrame的中文MDN地址：[https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame][2]\n\n\n - 复杂的计算操作使用Web Workers\n如果有需要复杂的数据操作，比如对一个有一个个元素的数组遍历求和，那么Web Workers在适合不过了。\n\nWeb Workers可以让JavaScript脚本运行在后台线程（类似于创建一个子线程），而后台线程不会影响到主线程中的页面。不过，使用Web Workers创建的线程是不能操作DOM树。\n有关Web Workers的更多可以查看MDN详解：[https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API/Using_web_workers][3]\n - css放在头部，js放在尾部。\n\n读过前面js运行机制的应该知道页面渲染是怎样一个过程，不再赘述了。css放在头部会避免生成html树之后重新布局的闪屏现象，js一般对页面的影响较大，一般放在尾部最后执行。\n\n - 事件防抖（debounce）与节流（throttle）\n针对高频触发的事件（mousemove、scroll）等事件，如果不加以控制会在短时间内触发很多事件。\n\n函数防抖是指频繁触发的情况下，只有足够的空闲时间，才执行代码一次。场景：注册时邮箱的输入框，随着用户的输入，实时判断邮箱格式是否正确，当第一次输入事件触发，设置定时：在800ms之后执行检查。假如只过了100ms，上次的定时还没执行，此时清除定时，重新定时800ms。直到最近一次的输入，后面没有紧邻的输入了，这最近一次的输入定时计时结束，终于执行了检查代码。\n\n```\nconst filter  = /^([a-zA-Z0-9_\\.\\-])+\\@(([a-zA-Z0-9\\-])+\\.)+([a-zA-Z0-9]{2,4})+$/;  \n$(\"#email\").on(\"keyup\",checkEmail());  \nfunction checkEmail(){  \n    let timer=null;  \n    return function (){  \n        clearTimeout(timer);  \n        timer=setTimeout(function(){  \n            console.log('执行检查');  \n        },800);  \n    }  \n}  \n```\n\n函数节流是指一定时间内js方法只跑一次。就是本来一秒要执行100次的变成一秒执行10次。\n场景：函数节流应用的实际场景，多数在监听页面元素滚动事件的时候会用到。\n```\nvar canRun = true;\ndocument.getElementById(\"throttle\").onscroll = function(){\n    if(!canRun){\n        // 判断是否已空闲，如果在执行中，则直接return\n        return;\n    }\n\n    canRun = false;\n    setTimeout(function(){\n        console.log(\"函数节流\");\n        canRun = true;\n    }, 300);\n};\n```\n\n - Dom操作\n前端开发人员都知道Do操作是非常耗时的（曾亲测过30*30的表格遍历添加样式）。所以尽量避免频繁的Dom操作，如果避免不了就尽量对DOm操作做优化。\n\n    1.：缓存Dom查询，比如通过getElementByTagName('div')获取Dom集，而不是逐个获取。\n\n    2： 合并Dom操作，使用createDocumentFragment()\n\n```\n    var frag = document.createDocumentFragment()\n    for (i<10) {\n        var li = document.createElement('li')\n        frag.appendChild(li)\n    }\n    document.body.appendChild(frag)\n```\n     3： 使用React、Vue等框架的虚拟dom（原理目前还不明白），可以更快的实现dom操作。\n\n\n - 尽量避免重绘（rePaint）和回流（reFlow）\n如果使用js修改元素的颜色或者背景色就会触发重绘，重绘的开销还是比较昂贵的，因为浏览器会在某一个DOM元素的视觉效果改变后去check这个DOM元素内的所有节点。\n\n如果修改元素的尺寸和位置就会发生回流，回流开销更大，它会在某一个DOM元素的位置发生改变后触发，而且它会重新计算所有元素的位置和在页面中的占有的面积，这样的话将会引起页面某一个部分甚至整个页面的重新渲染。\n\n\n - css3硬件加速\n浏览器渲染时，会分为两个图层：普通图层和复合图层。\n\n普通文档流内可以理解为一个复合图层，absolute、fixed布局虽然可以脱离普通文档流，但它仍然属于普通图层，不会启动硬件加速。上面说的重绘（rePaint）和回流（reFlow）说的就是普通图层上的重绘和回流。\n\n复合图层会启动硬件加速。和普通图层不在同一个图层，所以复合图层不会影响普通图层，如果一个元素被提升到复合图层，再操作该元素时，就不会引起普通图层的重绘和回流，从而提升渲染性能。\n\n如何启动硬件加速：\n\n*1.使用translate3d和translateZ*\n\n```\nwebkit-transform: translateZ(0);\n-moz-transform: translateZ(0);\n-ms-transform: translateZ(0);\n-o-transform: translateZ(0);\ntransform: translateZ(0);\n\nwebkit-transform: translate3d(0,0,0);\n-moz-transform: translate3d(0,0,0);\n-ms-transform: translate3d(0,0,0);\n-o-transform: translate3d(0,0,0);\ntransform: translate3d(0,0,0);\n```\n\n*2.使用opacity*\n需要动画执行的过程中才会创建合成层，动画没有开始或结束后元素还会回到之前的状态\n\n*3.使用will-chang属性*\n这个属性比较不常用，一般配合opacity与translate使用\n\n**针对webkit浏览器，启用硬件加速有些时候可能会导致浏览器频繁闪烁或抖动，可以使用下面方法消除：**\n\n```\n-webkit-backface-visibility:hidden;\n-webkit-perspective:1000;\n```\n\n> 如果使用硬件加速，请使用z-index配合使用， 因为如果这个元素添加了硬件加速，并且index层级比较低， 那么在这个元素的后面其它元素（层级比这个元素高的，或者相同的，并且releative或absolute属性相同的）， 会默认变为复合层渲染，如果处理不当会极大的影响性能\n\n\n - 避免强制同步布局和布局抖动\n\n浏览器渲染过程为：js/css(javascript) > 计算样式(style) > 布局(layout) > 绘制(paint) > 渲染合并图层（Composite）\n\n**JavaScript**：JavaScript实现动画效果，DOM元素操作等。\n**Style（计算样式）**：确定每个DOM元素应该应用什么CSS规则。\n**Layout（布局）**：计算每个DOM元素在最终屏幕上显示的大小和位置。\n**Paint（绘制）**：在多个层上绘制DOM元素的的文字、颜色、图像、边框和阴影等。\n**Composite（渲染层合并）**：按照合理的顺序合并图层然后显示到屏幕上。\n\n\n\n在js中如果读取style属性的某些值就会让浏览器强行进行一次布局、计算，然后再返回值，比如：\n\n```\noffsetTop, offsetLeft, offsetWidth, offsetHeight\n\nscrollTop/Left/Width/Height\n\nclientTop/Left/Width/Height\n\nwidth,height\n\n请求了getComputedStyle(), 或者 IE的 currentStyle\n\n```\n\n**所以，如果强制浏览器在执行JavaScript脚本之前先执行布局过程，这就是所谓的强制同步布局。**\n比如下面代码：\n\n```\nrequestAnimationFrame(logBoxHeight);\n\n// 先写后读，触发强制布局\nfunction logBoxHeight() {\n    // 更新box样式\n    box.classList.add('super-big');\n\n    // 为了返回box的offersetHeight值\n    // 浏览器必须先应用属性修改，接着执行布局过程\n    console.log(box.offsetHeight);\n}\n\n// 先读后写，避免强制布局\nfunction logBoxHeight() {\n    // 获取box.offsetHeight\n    console.log(box.offsetHeight);\n\n    // 更新box样式\n    box.classList.add('super-big');\n}\n```\n在JavaScript脚本运行的时候，它能获取到的元素样式属性值都是上一帧画面的，都是旧的值。因此，如果你在当前帧获取属性之前又对元素节点有改动，那就会导致浏览器必须先应用属性修改，结果执行布局过程，最后再执行JavaScript逻辑。\n\n**如果连续多次强制同步布局，就会导致布局抖动**\n比如下面代码：\n\n```\nfunction resizeAllParagraphsToMatchBlockWidth() {\n  for (var i = 0; i < paragraphs.length; i++) {\n    paragraphs[i].style.width = box.offsetWidth + 'px';\n  }\n}\n```\n\n\n\n我们知道浏览器是一帧一帧的刷新页面的，对于每一帧，上一帧的布局信息都是已知的。\n强制布局就是使用js强制浏览器提前布局，比如下面代码：\n\n```\n// bed  每次循环都要去获取left ，就会发生一次回流\nfunction logBoxHeight() {\n  box.style.left += 10\n  console.log(box.style.left)\n}\n\n// goog \nvar width = box.offsetWidth;\n\nfunction resizeAllParagraphsToMatchBlockWidth() {\n  for (var i = 0; i < paragraphs.length; i++) {\n    // Now write.\n    paragraphs[i].style.width = width + 'px';\n  }\n}\n```\n\n - DOMContentLoaded与Load\nDOMContentLoaded 事件触发时，仅当DOM加载完成才触发DOMContentLoaded，此时样式表，图片，外部引入资源都还没加载。而load是等所有的资源加载完毕才会触发。\n\n```\n1. 解析HTML结构。\n2. 加载外部脚本和样式表文件。\n3. 解析并执行脚本代码。\n4. DOM树构建完成。//DOMContentLoaded\n5. 加载图片等外部文件。\n页面加载完毕。//load\n```\n\n - 视觉优化\n等待加载时间可以合理使用loading gif动图一定程度上消除用户等待时间的烦躁感\n\n## 代码性能\n代码对性能的影响可大可小，但是养成一个良好的写代码习惯和高质量的代码，会潜移默化的提高性能，同时也能提高自己的水平。废话不多说，直接看我总结的部分要点（因为这一部分知识点太多，需要大家写代码的时候多多总结）。\n\n - 避免全局查找\n访问局部变量会比访问全局变量快，因为js查找变量的时候现在局部作用局查找，找不到在逐级向上找。\n\n```\n// bad\nfunction f () {\n    for (...){\n        console.log(window.location.href)\n    }\n}\n\n//good\nfunction f () {\n    var href = window.location.href\n    for (...){\n        console.log(href)\n    }\n}\n```\n\n - 循环技巧\n\n```\n// bed \nfor(var i = 0; i < array.length; i++){\n    ....\n}\n// good\nfor(var i = 0, len = array.length; i < len; i++){\n    ....\n}\n// 不用每次查询长度\n\n```\n\n - 不要使用for in 遍历数组\nfor in是最慢的，其他的都差不多，其中直接使用for循环是最快的。for in只是适合用来遍历对象。\n\n - 使用+''代替String()吧变量转化为字符串\n\n```\nvar a = 12\n//bad\na = String(a)\n\n// good\nvar a = 12\na = a + ''\n```\n\n这个还有很多类似的，比如使用*1代替parseInt()等都是利用js的弱类型，其实这样对性能提升不是很大，网上有人测试过，进行十几万次变量转换，才快了零点几秒。\n\n - 删除dom\n\n删除dom元素要删除注册在该节点上的事件，否则就会产生无法回收的内存，在选择removeChild和innerHTML=''二者之间尽量选择后者，据说removeChild有时候无法有效的释放节点（具体原因不明）\n\n - 使用事件代理处理事件\n任何可以冒泡的事件都可以在节点的祖先节点上处理，这样对于子节点需要绑定相同事件的情况就不用分别给每个子节点添加事件监听，而是都提升到祖先节点处理。\n - 通过js生成的dom对象必须append到页面中\n\n在IE下，js创建的额dom如果没有添加到页面，这部分内存是不会被回收的\n\n - 避免与null比较\n可以使用下面方法替换与null比较\n1.如果该值为引用类型，则使用instanceof检查其构造函数\n2.如果该值为基本类型，使用typeof检查类型\n\n - 尽量使用三目运算符代替if else\n\n```\nif(a>b){num = a}\nelse{num = b}\n\n// 可以替换为\nnum = a > b ? a : b\n```\n\n - 当判断条件大于3中情况时，使用switch代替if\n因为switch的执行速度比if要快，也别是在IE下，速度大约是if的两倍\n\n\n> 先总结这么多，其实性能优化还有很多，像预加载、服务端渲染、css选择器优化等等。等有机会再总结\n\n    \n\n\n  [1]: https://segmentfault.com/a/1190000003991459\n  [2]: https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame\n  [3]: https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API/Using_web_workers","tags":["javascript"]},{"title":"js运行机制","url":"/zqt-blog/2018/02/03/js运行原理/","content":"\n## js运行机制 ##\n\n> 本章了解一下js的运行原理，了解了js的运行原理才能写出更优美的代码，提高运行效率，还能解决开发中遇到的不理解的问题。\n\n## 进程与线程 ##\n\n进程是cpu资源分配的最小单位，进程可以包含多个线程。 浏览器就是多进程的，每打开的一个浏览器窗口就是一个进程。\n\n线程是cpu调度的最小单位，同一进程下的各个线程之间共享程序的内存空间。\n\n可以把进程看做一个仓库，线程是可以运输的货车，每个仓库有属于自己的多辆货车为仓库服务（运货），每个仓库可以同时由多辆车同时拉货，但是每辆车同一时间只能干一件事，就是运输本次的货物。这样就好理解了吧。\n\n### 渲染进程\n\n浏览器包括4个进程：\n\n 1. 主进程（Browser进程），浏览器只有一个主进程，负责资源下载，界面展示等主要基础功能\n 2. GPU进程，负责3D图示绘制\n 3. 第三方插件进程，负责第三方插件处理\n 4. 渲染进程（Renderer进程），负责js执行，页面渲染等功能，也是本章重点内容\n\n渲染进程主要包括GUI渲染线程、Js引擎线程、事件循环线程、定时器线程、http异步线程。\n\n\n####  GUI渲染线程\n\n先看看浏览器得到一个网站资源后干了哪些事：\n\n 1. 首先浏览器会解析html代码（实际上html代码本质是字符串）转化为浏览器认识的节点，生成DOM树，也就是DOM Tree\n 2. 然后解析css，生成CSSOM（CSS规则树）\n 3. 把DOM Tree 和CSSOM结合，生成Rendering Tree(渲染树)\n\nGUI就是来干这个事情的，如果修改了一些元素的颜色或者背景色，页面就会重绘（Repaint），如果修改元素的尺寸，页面就会回流（Reflow），当页面需要Repaing和Reflow时GUI多会执行，进行页面绘制。\n\n*这里提示一点：Reflow比Repaint的成本更高，在js性能优化中会将如何避免Reflow和Repaint*\n\n#### JS引擎线程\n\njs引擎线程就是js内核，负责解析与执行js代码，也称为主线程。浏览器同时只能有一个JS引擎线程在运行JS程序，所以js是单线程运行的。\n\n需要注意的是，js引擎线程和GUI渲染线程同时只能有一个工作，js引擎线程会阻塞GUI渲染线程\n\n```\n<html>\n    <body>\n        <div id=\"div1\"> a </div>\n        <script>\n            document.getElementById('div1').innerHTML = 'b'\n        </script>\n        <div id='div2'> div2 </div>\n    </body>\n</html>\n```\n\n在浏览器渲染的时候遇到script标签，就会停止GUI的渲染，然后js引擎线程开始工作，执行里面的js代码，等js执行完毕，js引擎线程停止工作，GUI继续渲染下面的内容。所以如果js执行时间太长就会造成页面卡顿的情况，这也是后面性能优化的点。\n\n#### 事件循环线程\n\n事件循环线程用来管理控制事件循环，并且管理着一个事件队列（task queue），当js执行碰到事件绑定和一些异步操作时，会把对应的事件添加到对应的线程中（比如定时器操作，便把定时器事件添加到定时器线程），等异步事件有了结果，便把他们的回调操作添加到事件队列，等待js引擎线程空闲时来处理。\n\n#### 定时器线程\n\n由于js是单线程运行，所以不能抽出时间来计时，只能另开辟一个线程来处理定时器任务，等计时完成，把定时器要执行的操作添加到事件任务队列尾，等待js引擎线程来处理。这个线程就是定时器线程。\n\n#### 异步请求线程\n   \n当执行到一个http异步请求时，便把异步请求事件添加到异步请求线程，等收到响应（准确来说应该是http状态变化），把回调函数添加到事件队列，等待js引擎线程来执行。\n\n\n### Event Loop\n\n上面介绍了渲染进程中的5个主要的线程，可能看完上面对各个线程简单的介绍，还有点不明白他们之间到底怎么协作工作的，下面就从Event Loop的角度来聊一聊他们之间是怎样那么愉快合作的。\n\n已经知道了js是单线程运行的，也知道js中有同步操作和异步操作。同步和异步大家应该很熟了，不多介绍。\n\n同步操作运行在js引擎线程（主线程）上，会形成一个执行栈，而异步操作则在他们对应的异步线程上处理（比如：定时操作在定时器线程上；http请求则在异步请求线程上处理）。\n\n而事件循环线程则监视着这些异步线程们，等异步线程们里面的操作有了结果（比如：定时器计时完成，或者http请求获取到响应），便把他们的毁掉函数添加到事件队列尾部，整个过程中执行栈、事件队列就构成Event Loop。\n\n请看网络盗图：\n\n\n![图片描述][4]\n\n这是网络上对Event Loop的解释图，相信大家现在能明白这张图的含义了。\n\n### 有关定时器（setTimeout、setInterval）的更多趣事\n\n\n#### 定时器会按照规定时间执行吗？\n\n定时器是规定在一段时间之后执行一段代码，但是在js执行中不会准确无误的按照预期的时间去执行定时器里面的代码。\n\n一个原因是W3C标准规定setTimeout中最小的时间周期是4毫秒，凡是低于4ms的时间间隔都按照4ms来处理。\n\n其实还有一个重要的原因，如果仔细看上面的文章，大家应该会想到在js执行的时候，主线程碰到定时器的时候，是不会直接处理的，应该是先把定时器事件交给定时器线程去处理，这时主线程继续执行下面的代码，同时定时器线程开始计时处理，等到计时完毕，事件循环线程会把定时器要执行的操作放在事件队列末尾，等主线程空闲的时候再来执行事件队列里面的操作。\n\n#### 应该使用setTimeout还是setInterval\n\n使用setTimeout模拟setInterval代码类似以下代码：\n\n```\nvar say = function() {\n    setTimeout(say, 1000)\n    console.log('hello world')\n}\n\nsetTimeout(say, 1000)\n```\n这样js碰到定时器，会交给定时器线程处理，然后等计时完毕，定时器里面的操作添加到事件队列，等主线程空闲去执行，主线程执行的时候又会发遇到定时器，这是又开始执行上面的一系列操作。\n\n你会发现，这样做会在每一次定时器执行完毕才开始下一个定时器，其中的误差只是等待主线程空闲所需要等待的时间。\n\n而setInterval是规定每隔固定的时间就往定时器线程中推入一个事件，这样做有一个问题，就是累积效应。\n\n - 累积效应：就是如果定时器里面的代码执行所需的时间大于定时器的执行周期，就会出现累计效应，简单来说就是上一次定时器里面的操作还没执行完毕，下一次定时器事件又来了\n\n累积效应会导致有些事件丢失，具体为什么会丢失，感兴趣的可以看[这篇文章][1]，所以为了保险起见，尽量去使用setTimeout而不使用setInterval。\n\n如果有对setTimeout非常感兴趣的同学，我非常推荐大家去看看[80% 应聘者都不及格的 JS 面试题][2]这篇文章。\n\n### macrotask与microtask\n\nmicrotask是Promise里一个新的概念。\n\n####macrotask\n\n - macrotask中的事件都是放在一个事件队列中的，而这个队列由事件触发线程维护\n - macrotask（又称之为宏任务），可以理解是每次执行栈执行的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）\n - 每一个task会从头到尾将这个任务执行完毕，不会执行其它\n - 浏览器为了能够使得JS内部task与DOM任务能够有序的执行，会在一个task执行结束后，在下一个 task 执行开始前，对页面进行重新渲染\n\n#### microtask\n\n \n - microtask（又称为微任务），可以理解是在当前 task 执行结束后立即执行的任务\n - microtask中的所有微任务都是添加到微任务队列（Job Queues）中，等待当前macrotask执行完毕后执行，而这个队列由JS引擎线程维护\n - 在当前task任务后，下一个task之前，在渲染之前执行\n - 所以它的响应速度相比setTimeout（setTimeout是task）会更快，因为无需等渲染\n - 也就是说，在某一个macrotask执行完后，就会将在它执行期间产生的所有microtask都执行完毕（在渲染前）\n\n请看网络盗图：\n\n\n![图片描述][5]\n\n所以js运行过程：\n\n - 执行一个宏任务（栈中没有就从事件队列中获取）\n - 执行过程中如果遇到微任务，就将它添加到微任务的任务队列中\n - 宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）\n - 当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染\n - 渲染完毕后，JS线程继续接管，开始下一个宏任务（从事件队列中获取）\n\n有关macrotask和microtask的分析借鉴于[从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理][3]\n\n\n  [1]: https://juejin.im/post/59cf06745188253fbe466f78\n  [2]: https://juejin.im/post/58cf180b0ce4630057d6727c\n  [3]: https://juejin.im/post/5a6547d0f265da3e283a1df7\n  [4]: https://image-static.segmentfault.com/138/714/1387142244-5a75a1f21e0d8_articlex\n  [5]: https://image-static.segmentfault.com/380/645/38064528-5a75b4ca8bcd4_articlex","tags":["javascript"]},{"title":"作用域与闭包","url":"/zqt-blog/2018/02/02/作用域与闭包/","content":"\n## 作用域与闭包 ##\n\n> 如何用js创建10个button标签，点击每个按钮时打印按钮对应的序号？\n\n看到上述问题，如果你能看出来这个问题实质上是考对作用域的理解，那么恭喜你，这篇文章你可以不用看了，说明你对作用域已经理解的很透彻了，但是如果你看不出来这是一道考作用域的题目，那么请看下文...\n\n### 工作模式\n 在所有的语言中，作用域一般有两种主要的工作模式：词法作用域和动态作用域。词法作用域就是定义在词法阶段的作用域，是由写代码时将变量和块作用域写在哪里来决定的，不会改变。而动态作用域并不关心函数和作用域是如何声明以及在任何处声明的，只关心它们从何处调用。javascript是词法作用域工作模式。 看下面的例子体会一下：\n\n```\nfunction static () {\n    var foo=1\n    alert(foo)         \n}      \n!function () {\n    var foo=2\n    static(); // 如果是词法作用域会打印1，如果是动态作用域则打印2   \n}();\n\n```\n### 作用域\n\n在es6之前javascript的作用域只有全局作用域和局部作用域（函数作用域），是没有块级作用域的。在es6中提供了let，可以简单的定义一个块级作用域变量。使用let可以将变量绑定在所在的任意作用域中（通常是{...}内部），也就是说let为其声明的变量隐式的劫持了所在的块级作用域。\n为了方便理解作用域，需要知道下面几个概念：\n\n - 自由变量：当前作用域没有的变量就称为自由变量\n - 作用域链：当前作用域没定义的变量（自由变量），会逐级向父级作用域寻找\n - 父级作用域： 哪个作用域定义了当前作用域，那就是当前作用域的父级作用域\n\n```\nvar a = 1\nfunction foo () {\n    alert(a) // 在foo函数作用域中a就是自由变量，因为在foo中没有定义a，便向父级作用域（此为全局作用域）查找\n}\n```\n\n### 作用域提升\n\n 关于作用域提升与js引擎线程运行原理有关，js引擎运行时会执行三步操作，第一步是先检查你的js代码有没有低级的语法错误，第二步是预编译，第三步是根据代码顺序解释一句执行一句。\n\n第一步和第三步都很好理解，重点解释一下第二步预编译，所谓预编译就是在执行代码会把所有的变量声明和函数声明预先处理。当你写了一句var a = 1时，javascript会当成两个操作：var a;和a = 1;第一个是在预编译中执行的，此时只是声明了a这个变量，没有赋值操作，所以此阶段a的值为undefined。\n正是因为预编译存在，所以javascript会存在作用域变量提升。看下面的例子可以更好的理解：\n\n```\nconsole.log(a) // undefined\nvar a = 1\n\n//上述代码可以这样理解\nvar a // 此时a的值为undefined\nconsole.log(a)\na = 1\n```\n\n变量提升有两点需要记住：\n\n - 只有声明才会被提升\n\n```\nfoo()\nfoo =  function() { // 这里只是赋值表达式，不会被提升\n    console.log(1)\n}\nfunction foo() { // 以function开头定义的函数才是声明，会被提升\n    console.log(2)\n}\n\n// 可以这样理解\n\nfunction foo() {\n    console.log(2)\n}\nfoo() // 2\nfoo =  function() {\n    console.log(1)\n}\n```\n\n - 每个作用域都会提升，提升到当前作用域\n\n```\nfoo()\nfunction foo () {\n    console.log(a) // undefinded\n    var a = 1\n}\n\n//可以这样理解\n\nfunction foo () {\n    var a // undefined\n    console.log(a)\n    a = 1\n}\nfoo()\n```\n\n### 闭包\n\n对于闭包的定义，各种说法都有，在KYLE SIMPSON著的《你不知道的javascript》中是这样定义的：当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前此法作用域之外执行。\n\n还有网络上不同版本的定义，还有的说在函数中定义函数，并返回函数，就是闭包。其实都差不多，各个版本都有一定的道理，但也不一定全对，因为目前还没有一个完美的、得到广泛认可的公认的定义。所以这里我们对闭包的定义也不便做更多的解释。如果你觉得有一个概念定义会对你理解闭包有帮助，我比较推荐《你不知道的javascript》中对闭包的定义。\n\n从下面一个小例子先来认识一下闭包：\n\n```\nfunction foo () {\n    var a = 1\n    function fn() {\n        console.log(a)\n    }\n    return fn()\n}\nvar bar = foo()\nbar() // 1\n```\n上述就是一个简单的闭包的例子，fn函数可以被执行，并且是在fn函数被定义的词法作用域的外面执行。\n\n通常由于js引擎的垃圾回收机制，一个普通的函数在执行之后内部作用域以及内部变量会被销毁，垃圾机制用来回收释放不再使用内存空间。\n\n正常来说，当foo执行之后，foo函数内部作用域会被销毁，但是闭包就会阻止垃圾回收，事实上内部作用域还存在，因为fn函数还在使用使用foo函数的内部作用域。\n\n> 到现在为止应该对闭包有个初步的认识了，下面就来回过头去看看最开始预留的问题：如何用js创建10个button标签，点击每个按钮时打印按钮对应的序号？\n\n先看一个错误的示例：\n\n```\nvar i = 1\nfor (i=1;i<=10;i++){\n    var btn = document.createElement(\"BUTTON\")\n    btn.innerHTML = i\n    btn.addEventListener('click',function(event){\n        alert(i)\n    })\n    document.getElementById(\"div\").appendChild(btn)\n}\n```\n大家可以把上面的代码测试一下，你会发现屏幕上出现了10个按钮，序号从0到9，但是当你点击每一个按钮的时候发现都是弹出11，这是因为当你点击按钮的时候for循环早已经执行完毕，这时i的值已经变成11，当点击执行到alert(i)的时候，发现当前作用域没有i，便去父作用域寻找i，这时i的值为11，所以会打印出11。\n\n那么应该怎样才能达到我们想要的效果呢，我们知道IIFE函数其实也是普通函数，既然是函数就可以可以有自己的作用域，不妨利用IIFE函数来试试：\n\n```\nvar i = 1\nfor (i=1;i<=10;i++){\n    (function(num){\n        var btn = document.createElement(\"BUTTON\")\n        btn.innerHTML = num\n        btn.addEventListener('click',function(event){\n            alert(num)\n        })\n        document.getElementById(\"div\").appendChild(btn)\n    })(i)    \n}\n```\n\n每次循环创建一个IIFE函数，每个IIFE函数都有自己的局部作用域，这里通过向IIFE函数传值的方式在IIFE函数中创建局部变量num，每一个IIFE函数都有自己的num变量，这样在点击执行alert(num)的时候就会在当前作用域找到num。\n\n\n\n\n\n","tags":["javascript"]},{"title":"作用域与原型链","url":"/zqt-blog/2018/02/01/原型链与继承/","content":"## 作用域与原型链 ##\n\n>  注意：本章讲的是在es6之前的原型链与继承。es6引入了类的概念，只是在写法上有所不同，原理是一样的。\n\n### 几个面试常问的几个问题，你是否知道\n\n 1. instanceof的原理\n 2. 如何准确判断变量的类型\n 3. 如何写一个原型链继承的例子\n 4. 描述new一个对象的过程\n\n> 也许有些同学知道这几个问题的答案，就会觉得很小儿科，如果你还不知道这几个问题的答案或者背后所涉及到的知识点，那就好好看完下文，想必对你会有帮助。先不说答案，下面先分析一下涉及到的知识点。\n\n### 什么是构造函数\nJavaScript没有类的概念，JavaScript是一种基于对象的语言，除了五中值类型（number boolean string null undefined）之外，其他的三种引用类型（object、Array、Function）本质上都是对象，而构造函数其实也是普通的函数，只是可以使用构造函数来实例化对象。\n    事实上，当任意一个普通函数用于创建一类对象时，它就被称作构造函数。像js的内置函数Object、Array、Date等都是构造函数。\n在定义构造函数有以下几个特点：\n\n - 以大写字母开头定义构造函数\n - 在函数内部对新对象（this）的属性进行设置\n - 返回值必须是this，或者其它非对象类型的值\n\n下面定义一个简单的、标准的构造函数：\n\n```\nfunction Obj(){\n    this.name = 'name'\n    return this // 默认有这一行 \n}\nvar foo = new Obj() // 使用上面定义的构造函数创建一个对象实例\n```\n\n### 原型特性\njs原型有5个特点，记住这5条特点，相信你一定会弄明白长期困扰你的原型关系。\n\n 1. 除了null所有引用类型（Object、Array、Function）都有对象特性，也就是都可以自由扩展属性。\n 2. 所有引用类型都有一个_proto_属性（又称为：隐式属性），_proto_是一个普通的对象。所有的对象都会有一个constructor属性，constructor始终指向创建当前对象的构造函数\n 3. 所有的函数都有一个prototype属性（又称为：显式属性），也是一个普通对象，这个prototype有一个constructor属性指向该函数。\n 4. 所有的引用类型的_proto_属性指向它的构造函数的prototype属性（比如：obj._proto_指向Object.prototype,obj是定义的一个普通对象，Object是js的内置函数）\n 5. 当从一个对象中获得某个属性时，如果这个对象没有该属性，就会去它的_proto_（也就是它的构造函数的prototype）中去寻找\n\n先来解释一下这几条：\n第一条的自由扩展性可以通过一个简单的例子来看\n\n```\nvar obj = {}\nobj.name = 'name'\nconsole.log(obj) // {name:'name'}\n```\n第二条和第三条是javascript就是这么规定的，没什么好说的\n\n第四条可以这么理解，当定义一个引用类型的变量var obj = {} 其实是var obj = new Object()的语法糖，这样Object就是obj的构造函数，根据第4条规定，obj._proto_ === Object.prototype，如果不理解可以看看上一章我们讲的js内置函数和上面讲的构造函数\n\n第五条应该好理解，当从obj中获取某个属性时，如果obj中没有定义该属性，就会逐级去它的_proto_对象中去寻找，而它的_proto_指向Object的prototype，也就是从Object的prototype对象中去寻找。\n\n### 原型链与继承\n\n> 如果上面明白了原型，那么原型链就会很好理解\n\n根据原型定义的第4条和第5条，很容易发现通过对象的_proto_和函数的prototype把我们变量和构造函数（自定义的构造函数以及内置构造函数）像链子一样链接起来，所以又叫他原型链。\n\n有了原型链，就有了继承，继承就是一个对象像继承遗产一样继承从它的构造函数中获得一些属性的访问权。从下面一个小例子理解：\n\n```\nfunction Animal (name) {\n  // 属性\n  this.name = name || 'Animal';\n  // 实例方法\n  this.sleep = function(){\n    console.log(this.name + '正在睡觉！');\n  }\n}\n// 原型方法\nAnimal.prototype.eat = function(food) {\n  console.log(this.name + '正在吃：' + food);\n};\n// 原型继承\nfunction Cat(){ \n}\nCat.prototype = new Animal();\nCat.prototype.name = 'cat';\n```\n上面例子中在Foo构造函数的prototype中自定义一个somefn函数。然后通过new Foo()创建一个对象实例并赋值给bar变量，此时bar就等于{name:'bar'}。然后bar.somefn就去bar对象中寻找somefn这个属性，发现找不到，然后就去它的_proto_（其实就是Foo的prototype）中寻找，发现somefn就在Foo的prototype中定义了，就可以愉快的调用并执行somefn了。\n\n这里其实就是一个原型链与继承的典型例子，开发中可能构造函数复杂一点，属性定义的多一些，但是原理都是一样的。\n\n> 留一个问题，根据上面例子，如果执行bar.stString(),应该去哪里找toString这个方法？ （提示：prototype也是普通对象，也有自己的_proto_）\n\n### 几种继承方式\n\n这几种都是es5中的继承，es6中提供了class类，继承起来更方便。\n\n#### 原型继承\n上述例子就是一个原型继承：\n```\nfunction Animal (name) {\n  // 属性\n  this.name = name || 'Animal';\n  // 实例方法\n  this.sleep = function(){\n    console.log(this.name + '正在睡觉！');\n  }\n}\n// 原型方法\nAnimal.prototype.eat = function(food) {\n  console.log(this.name + '正在吃：' + food);\n};\n// 原型继承\nfunction Cat(){ \n}\nCat.prototype = new Animal();\nCat.prototype.name = 'cat';\n\nvar cat = new Cat()\nconsole.log(cat instanceof Animal); //true \nconsole.log(cat instanceof Cat); //true\n```\n**优点：**\n\n - 非常纯粹的继承关系，实例是子类的实例，也是父类的实例\n - 简单，易于实现\n\n**缺点**\n\n - 要想为子类新增属性和方法，必须要在new Animal()这样的语句之后执行，不能放到构造器中\n - 无法实现多继承\n - 来自原型对象的引用属性是所有实例共享的（严重缺点）\n - 创建子类实例时，无法向父类构造函数传参（严重缺点）\n\n#### 构造继承\n\n```\nfunction Animal (name) {\n  // 属性\n  this.name = name || 'Animal';\n  // 实例方法\n  this.sleep = function(){\n    console.log(this.name + '正在睡觉！');\n  }\n}\n// 原型方法\nAnimal.prototype.eat = function(food) {\n  console.log(this.name + '正在吃：' + food);\n};\n// 构造继承\nfunction Cat(name){\n  Animal.call(this);\n  this.name = name || 'Tom';\n}\n\n// Test Code\nvar cat = new Cat();\nconsole.log(cat.name);\nconsole.log(cat.sleep()); // Tom正在睡觉！\n// console.log(cat.eat('fish')); // cat.eat is not a function\nconsole.log(cat instanceof Animal); // false\nconsole.log(cat instanceof Cat); // true\n```\n**优点**\n\n - 解决了1中，子类实例共享父类引用属性的问题\n - 创建子类实例时，可以向父类传递参数\n - 可以实现多继承\n**缺点**\n - 实例并不是父类的实例，只是子类的实例\n - 只能继承父类的实例属性和方法，不能继承原型属性/方法\n - 无法实现函数复用，每个子类都有父类实例函数的副本，影响性能\n\n#### 实例继承\n\n```\nfunction Animal (name) {\n  // 属性\n  this.name = name || 'Animal';\n  // 实例方法\n  this.sleep = function(){\n    console.log(this.name + '正在睡觉！');\n  }\n}\n// 原型方法\nAnimal.prototype.eat = function(food) {\n  console.log(this.name + '正在吃：' + food);\n};\n\n// 实例继承\nfunction Cat(name){\n  var instance = new Animal();\n  instance.name = name || 'Tom';\n  return instance;\n}\nvar cat = new Cat(); // 或者可以直接var cat = Cat()\nconsole.log(cat.name);\nconsole.log(cat.sleep()); // Tom正在睡觉！\nconsole.log(cat.eat('fish')); // Tom正在吃：fish\nconsole.log(cat instanceof Animal); // true\nconsole.log(cat instanceof Cat); // false\n```\n**优点**\n\n - 不限制调用方式，不管是new Cat()还是Cat(),返回的对象具有相同的效果\n\n**缺点**\n\n - 实例是父类的实例，不是子类的实例\n - 不支持多继承\n\n#### 组合继承\n\n```\nfunction Animal (name) {\n  // 属性\n  this.name = name || 'Animal';\n  // 实例方法\n  this.sleep = function(){\n    console.log(this.name + '正在睡觉！');\n  }\n}\n// 原型方法\nAnimal.prototype.eat = function(food) {\n  console.log(this.name + '正在吃：' + food);\n};\n// 组合继承\nfunction Cat(name){\n  Animal.call(this);\n  this.name = name || 'Tom';\n}\nCat.prototype = new Animal();\nCat.prototype.constructor = Cat;\nvar cat = new Cat();\nconsole.log(cat.name);\nconsole.log(cat.sleep()); // Tom正在睡觉！\nconsole.log(cat.eat('fish')); // Tom正在吃：fish\nconsole.log(cat instanceof Animal); // true\nconsole.log(cat instanceof Cat); // true\n\n```\n**优点**\n\n - 弥补了方式2的缺陷，可以继承实例属性/方法，也可以继承原型属性/方法\n - 既是子类的实例，也是父类的实例\n - 不存在引用属性共享问题\n - 可传参\n - 函数可复用\n**缺点**\n - 调用了两次父类构造函数，生成了两份实例（子类实例将子类原型上的那份屏蔽了）\n\n#### 寄生继承\n\n```\nvar ob = {name:\"小明\",friends:['小花','小白']};\n\nfunction object(o){\n  function F(){}//创建一个构造函数F\n  F.prototype = o;\n  return new F();\n}\n\n//上面再ECMAScript5 有了一新的规范写法，Object.create(ob) 效果是一样的  \n\nfunction createOb(o){\n   var newob = object(o);//创建对象\n   newob.sayname = function(){//增强对象\n       console.log(this.name);\n   }\n\n   return newob;//指定对象\n}\n\nvar ob1 = createOb(ob);\nob1.sayname()\n```\n\n> 寄生继承原理尚不明白。\n\n####寄生组合继承\n\n寄生组合继承有两种方式：\n\n*第一种：利用创建没有实例方法的函数*\n```\nfunction Animal (name) {\n  // 属性\n  this.name = name || 'Animal';\n  // 实例方法\n  this.sleep = function(){\n    console.log(this.name + '正在睡觉！');\n  }\n}\n// 原型方法\nAnimal.prototype.eat = function(food) {\n  console.log(this.name + '正在吃：' + food);\n};\n\n//寄生组合继承\nfunction Cat(name){\n  Animal.call(this);\n  this.name = name || 'Tom';\n}\n(function(){\n  // 创建一个没有实例方法的类\n  var Super = function(){};\n  Super.prototype = Animal.prototype;\n  //将实例作为子类的原型\n  Cat.prototype = new Super();\n  Cat.prototype.constructor = Cat;\n})();\n\nvar cat = new Cat();\nconsole.log(cat.name);\nconsole.log(cat.sleep()); // Tom正在睡觉！\nconsole.log(cat.eat('fish')); // Tom正在吃：fish\nconsole.log(cat instanceof Animal); // true\nconsole.log(cat instanceof Cat); //true\n\n```\n*第二种：利用Object.create函数*\n\n```\n// 寄生继承核心方法\nfunction inheritPrototype(Parent, Children){\n    var prototype = Object.create(Parent.prototype);\n    prototype.constructor = Children;\n    Children.prototype = prototype;\n}\n// 父类\nfunction Animal (name) {\n  // 属性\n  this.name = name || 'Animal';\n  // 实例方法\n  this.sleep = function(){\n    console.log(this.name + '正在睡觉！');\n  }\n}\n// 原型方法\nAnimal.prototype.eat = function(food) {\n  console.log(this.name + '正在吃：' + food);\n};\n\n// 子类\nfunction Cat(name){\n  Animal.call(this);\n  this.name = name || 'Tom';\n}\ninheritPrototype(Animal, Cat)\n\nvar cat = new Cat();\nconsole.log(cat.name);\nconsole.log(cat.sleep()); // Tom正在睡觉！\nconsole.log(cat.eat('fish')); // Tom正在吃：fish\nconsole.log(cat instanceof Animal); // true\nconsole.log(cat instanceof Cat); //true\n\n```\nObject.create其实与以下代码等价\n\n```\nfunction object(o){\n    function f(){}\n    f.prototype = o;\n    return new f();\n}\n```\n\n**优点**\n\n - 最完美的继承解决方案\n\n**缺点**\n\n - 实现复杂\n\n### 解答一下最一开始提出的问题\n\n看到这里应该对原型链与继承的原理有所了解了，再回头看上面的问题，你也会发现这都是小儿科。\n第一个问题：instanceof原理？\n\n```\nvar arr = []\narr instanceof Array\n```\ninstanceof原理就是利用了原型链，当执行arr instanceof Array时，会从arr的_proto_一层一层往上找，看是否能不能找到Array的prototype。\n我们知道var arr = [] 其实是var arr = new Array()的语法糖，所以arr的_proto_指向Array的prototype，结果返回true\n\n第二个问题：如何准确判断变量类型?\n可以使用instanceof帮助我们判断，而不是typeof\n\n第三个问题：如何写一个原型链继承的例子？\n\n```\nfunction Foo () {\n    this.name = 'name'\n    this.run = function () {\n        console.log(this.name)\n    }\n}\nfunction Bar () {}\nBar.prototype = new Foo() // 从构造函数Foo中继承\nvar baz = new Bar()\nbaz.run() // 打印出 'name'\n```\n\n第四个问题：描述new一个对象的过程\n\n 1. 创建一个新的对象，\n 2. 获得构造函数的prototype属性，并把prototype赋值给新对象的_proto_,this指向这个新对象\n 3. 执行构造函数，返回构造函数的内容\n\n","tags":["javascript"]},{"title":"简洁的纯css代码美化复选框、单选框和滑动按钮","url":"/zqt-blog/2017/12/13/如何使用最简单纯Css代码美化checkbox复选框、radios单选框和滑动按钮/","content":"\n## 最简洁的代码美化复选框、单选框和滑动按钮 ##\n\n### 效果预览 ###\n![图片描述][1]\n\n### 1. 复选框 ###\n\n```\n<html>\n\n<head>\n    <style type=\"text/css\">\n        .switch {\n            margin: 20px 20px 0 0;\n            display: flex;\n            align-items: center;\n            width: auto;\n        }\n        .checkbox-input {\n            display: none\n        }\n        .checkbox {\n            -webkit-transition: background-color 0.3s;\n            transition: background-color 0.3s;\n            background-color: #fff;\n            border: 1px solid #d7d7d7;\n            border-radius: 3px;\n            width: 16px;\n            height: 16px;\n            vertical-align:middle;\n            margin: 0 5px;\n        }\n        .checkbox-input:checked+.checkbox {\n            background-color: #57ad68;\n        }\n        .checkbox-input:checked+.checkbox:after {\n            content: \"\\2714\";\n            display: inline-block;\n            height: 100%;\n            width: 100%;\n            color: #fff;\n            text-align: center;\n            line-height: 16px;\n            font-size: 12px;\n            box-shadow: 0 0 4px #57ad68;\n        }\n    </style>\n</head>\n\n<body>\n    <label class=\"switch\">\n        <input class=\"checkbox-input\" id=\"checkbox\" type=\"checkbox\" name=\"demo-checkbox1\">\n        <label class=\"checkbox\" for=\"checkbox\"></label>\n        <span>Hello</span>\n    </label>\n</body>\n\n</html>\n```\n\n### 2. 单选框 ###\n\n```\n<html>\n\n<head>\n    <style type=\"text/css\">\n        .switch {\n            display: flex;\n            align-items: center;\n            width: auto;\n            float: left;\n        }\n        .radio-beauty-container .radio-beauty {\n            width: 16px;\n            height: 16px;\n            box-sizing: border-box;\n            display: inline-block;\n            border: 1px solid #d7d7d7;\n            margin: 0 5px;\n            border-radius: 50%;\n            transition: 0.2s;\n        }\n        .radio-beauty-container input[type=\"radio\"]:checked+.radio-beauty {\n            border: solid 1px green;\n            padding: 3px;\n            background-color: green;\n            background-clip: content-box;\n            box-shadow: inset 0 0 1px rgba(0,128,0, 0.2), 0 0 3px green;\n        }\n    </style>\n</head>\n\n<body>\n    <div class=\"radio-beauty-container\">\n        <label class=\"switch\">\n            <span class=\"radio-name\">radio2</span>\n            <input type=\"radio\" name=\"radioName\" id=\"radioName2\" hidden/>\n            <label for=\"radioName2\" class=\"radio-beauty\"></label>\n        </label>\n        <label class=\"switch\">\n            <span class=\"radio-name\">radio3</span>\n            <input type=\"radio\" name=\"radioName\" id=\"radioName3\" hidden/>\n            <label for=\"radioName3\" class=\"radio-beauty\"></label>\n        </label>\n    </div>\n</body>\n\n</html>\n```\n### 3. 滑动按钮 ###\n\n```\n<html>\n\n<head>\n    <style type=\"text/css\">\n        .switch-slide-label {\n            display: block;\n            width: 34px;\n            height: 18px;\n            background: #ccc;\n            border-radius: 30px;\n            cursor: pointer;\n            position: relative;\n            -webkit-transition: 0.3s ease;\n            transition: 0.3s ease;\n        }\n        \n        .switch-slide-label:after {\n            content: '';\n            display: block;\n            width: 16px;\n            height: 16px;\n            border-radius: 100%;\n            background: #fff;\n            box-shadow: 0 1px 1px rgba(0, 0, 0, .1);\n            position: absolute;\n            left: 1px;\n            top: 1px;\n            -webkit-transform: translateZ(0);\n            transform: translateZ(0);\n            -webkit-transition:0.3s ease;\n            transition:0.3s ease;\n        }\n        \n        .switch-slide input:checked+label {\n            background: #34bf49;\n            transition: 0.3s ease;\n        }\n        .switch-slide input:checked+label:after {\n            left: 17px;\n        }\n\n    </style>\n</head>\n\n<body>\n    <div class=\"radio-beauty-container\">\n            <label class=\"switch-slide\">\n                <input type=\"checkbox\" id=\"menu-right\" hidden>\n                <label for=\"menu-right\" class=\"switch-slide-label\"></label>\n            </label>\n    </div>\n</body>\n\n</html>\n```\n\n\n  [1]: https://image-static.segmentfault.com/485/070/485070410-5a30c819ab8aa_articlex","tags":["css"]},{"title":"日常开发常用的css小技巧总结","url":"/zqt-blog/2017/12/05/日常开发常用的css小技巧总结/","content":"\n## css黑科技 ##\n\n **currentColor当前颜色**\n\n```\n<a href=\"##\" class=\"link\"><i class=\"icon\"></i>返回</a>\n.icon {\n  display: inline-block;\n  width: 16px; \n  height: 20px;\n  background-image: url(http:jartto.wang/test.png);\n  background-color: currentColor; /* 该颜色控制图标的颜色 */\n  background-position: 0 0;\n}\n.link:hover {\n  color: #333; /* 虽然改变的是文字颜色，但是图标颜色也一起变化了 */\n}\n```\n\n **vh、vw、vmin、vmax单位**\n浏览器的视口的宽、高被分为100份，1vh相当于浏览器高度的百分之一，即浏览器的高度为800px,则1vh=8px。\nvw宽度同理。vh、vw支持calc算法\n\n```\n.box{\n  height: calc(100vh - 50px);\n}\nh1 {\n  font-size: 8vw;\n}\n```\nvmin和vmax是与这次宽度和高度的最大值或最小值有关，取决于哪个更大和更小。例如，如果浏览器设置为\n1100px宽、700px高，1vmin会是7px,1vmax为11px。然而，如果宽度设置为800px，高度设置为1080px，\n1vmin将会等于8px而1vmax将会是10.8px。\n\n```\n.box{\n  height: calc(100vmax - 50px);\n}\n```\n\n **边框多个颜色**\n\n```\n.box{\n    border-style:solid;\n    border-color:red green blue pink;\n}\n```\n必须设置border-style才会有效果\n\n **css画小箭头**\n使用border和transparent属性实现\n\n```\n/*箭头向上*/\n.arrow-up {\n  width:0;\n  height:0;\n  border-left:30px solid transparent;\n  border-right:30px solid transparent;\n  border-bottom:30px solid #fff;\n}\n/*箭头向下*/\n.arrow-down {\n  width:0;\n  height:0;\n  border-left:20px solid transparent;\n  border-right:20px solid transparent;\n  border-top:20px solid #0066cc;\n}\n```\n\n **图片滤镜效果**\n使用filter属性可以实现各种各样的图片效果，包括以下属性\n\n```\ngrayscale 灰度\nsepia 褐色\nsaturate 饱和度\nhue-rotate 色相旋转\ninvert 反色\nopacity 透明度\nbrightness 亮度\ncontrast 对比度\nblur 模糊\ndrop-shadow 阴影\n```\n\n **浏览器滚动条美化（仅支持webkit内核浏览器）**\n\n```\n/*滚动条 start*/\n::-webkit-scrollbar {\n  width: 1px;\n  height: 4px;\n  background-color: #F5F5F5;\n}\n/*定义滚动条轨道 内阴影+圆角*/\n::-webkit-scrollbar-track {\n  box-shadow: inset 0 0 6px rgba(0,0,0,0.3);\n  background: #fff ;\n}\n/*定义滑块 内阴影+圆角*/\n::-webkit-scrollbar-thumb {\n  border-radius: 3px;\n  box-shadow: inset 0 0 6px rgba(0,0,0,.3);\n  // background-color:rgba(7, 170, 247, 0.7);\n  background-color: transparent;\n}\n::-webkit-scrollbar-thumb:hover {\n  border-radius: 3px;\n  box-shadow: inset 0 0 6px rgba(0,0,0,.3);\n  background-color:rgba(7, 170, 247, 1);\n}\n```\n\n **使用 :not() 在菜单上应用/取消应用边框**\n\n```\n.nav li:not(:last-child) {\n  border-right: 1px solid #666;\n}\n```\n\n **浏览器默认行高line-height一般为1.15倍，可以给body设置line-height:1来设置行高为1.0倍**\n\n```\nbody{\n      line-height: 1;\n}\n```\n\n **使用负的 nth-child 选择项目**\n在CSS中使用负的 nth-child 选择项目1到项目n。\n```\nli {\n  display: none;\n}\nli:nth-child(-n+3) {\n  display: block;\n}\n```\n **禁用鼠标事件**\n\n```\n.disabled {\n    pointer-events: none;\n}\n```\n\n","tags":["css"]}]